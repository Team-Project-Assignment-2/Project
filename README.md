Team software project: Assignment 2
Kaisa Alapiha
S Hasan
Shqipe Buzuku
Elissei Hilakivi

https://github.com/Team-Project-Assignment-2/Project


Description of the program

We have created a simple text program called “Animals House”. It can be considered as a sort of a pet game, where animals have preprogramed functionalities, which create a text output when used.
The code is very simple, well-organized, and understandable. It starts by prompting a question to the user “What would you like to do?” and gives the options “quit” or “list”. The code then initializes a short list with seven text elements referring to seven different kinds of animals: bear, cat, dog, bird, wolf, tiger, elephant, and sloth, respectively. 
 The code then proceeds to receive the feedback from the user and enters a “while” loop that will continue until the user decides to break it at any of the subsequent steps. Logically, if the option chosen to start with is “quit” the program stops without any further interactions. But if the option chosen is “list” the code goes on and proceeds to show the user the contents of the list in consecutive order for each element through a for loop. 
Next, a new question is prompted to the user: “Which animal do you want to see?” and expects user to type the name of the animal in response. The code then receives and evaluates the feedback from the user through a series of “if” conditions separate each of the cases. 
Inside the first case, which stands for “bear”, variables are initialized for weight (as zero) and animal name (as “bear”).  A new question is prompted to the user, simultaneously providing the user with the answer options: “What do you want to do? [Hunt, MakeSound, ComeHere, GiveName, back, quit]. If the option chosen is “back” the code goes back to the part of the code that prompts the question described in the previous paragraph. The option “quit” of course exits the program altogether. 
The options “MakeSound” and “ComeHere” simply print the reactions “Growl” and “walks to you”, although the option “ComeHere” first prints also the name. The option “Hunt” considers that hunting is not always effective, so it generates a random number from 0 to 9 and proceeds evaluate it, if the number is less than 6 (for 60% success rate), the algorithm adds 1 to the variable weight and then prints “Hunt was successful, “ + name + “ gains 1kg and weights now “ + wight + “ kg”. If the number is from 6 to 9, then the hunt is considered unsuccessful and instead it prints “Hunt failed, “ + name + “ still weights “+ weight + ” kg”, and of course does not increment the variable weight. Finally, the option “GiveName” prompts the request “Give me a name:” and proceeds to assign the name of the animal whatever input from the user is received. The program then returns to the “what do you want to do” question.
The cases for each of the other animals are almost identical, with only two differences being that the command “MakeSound” for each of the cases prints a different reaction and the method for feeding is either “Hunt” for wild animals or “Eat” for domestic animals. While for bear the reaction was “Growl”, for cat, dog, bird wolf and tiger the reactions obtained are “Meow”, “Woof”, “Chirp”, “Howl” and “Roar” respectively. The other difference is that for domestic animals (cat and dog) the method “Hunt” is replaced by “Eat”, in which the variable weight is incremented by 1 without condition, and then prints (name + “ eats, gains 1 kg and weighs now “ + weight + “ kg”). The rest of the code is identical and for each of the animals, also giving the options to change the name, feed and call the animal. Naturally, the options to go back and quit the program are also given inside the case for every animal.  
After exiting each of the cases, the variables for name and weight of the animals are reset to the originals (zero for the weight and bear, cat, dog, bird, wolf, and tiger for the names) for every loop of the code when it goes back to the question “Which animal would you like to see?”. Also, worth pointing out, the loop is infinite unless the user chooses the option “quit” at any relevant prompt.  


How it was done

Task considered learning of how to use Git and Github, and then creating a simple text program as a team using Git and Github. To make the workflow fluent, we divided the tasks so that Kaisa focused on creating the program, while Elissei focused on learning how to use Git and Github, with the help of S Hasan. Unfortunately, Shiqpe was not able to attend to the first meetings and joined us only at the middle of the second week. After one-week Kaisa managed to create the core of the program, considering approximately 70% of the program. There were practically all the functionalities and four of the animals created to the program. After that, Elissei held individual instruction sessions with each team member, on how to use Git and Github, and ensured that everyone achieves the learning objectives of the given Git exercises. He created an organizational account to the Github and created two repositories – one for practice (Assignment-2), and one for the final version of the program (Project).
Next, we had a meeting were the work on the rest of the program was divided between each team member. Practically, everyone except Kaisa, got to create an additional animal, besides that Shqipe signed up to write a description of the program, and Elissei signed up to work on exceptions that might be caused by invalid input of the user, and finishing the work report. Finally, we had a meeting, were everyone committed their part of the program to the Github. After that Elissei wrote the report and included Shqipe’s description of the program to it.  


In more detail

In the first phase of the project, we analyzed the requirements of the project set by a teacher and planned how we are going to implement them to life, considering given schedule, and competence of the team . We agreed on what each of us is going to do – what roles there is going to be. Since requirements were clear, there was no need for additional definition of them. 
In the next phase we created an architecture of the software, considering given requirements. Based on our competence, we agreed to use Visual Studio and Visual Studio Code as code development environment, and C# as a programming language. Because the task was to create a simple text program, we agreed that there is no necessity to create methods, classes, and objects in the software, so we decided that there is going to be only main method, considering all the program. The most difficult part was to learn how to create a software as a team using version control software, so meanwhile the development phase was ongoing, one member of the team had to focus entirely on learning how to use the version control and explain it to the other team members in a simple way.  
During the development phase, we tested our program constantly. After each addition or modification, the program has been tested, considering functionality  and visual outlook of it. Multiple tests had been made to make the program run fluently without crashing, if user would try to insert invalid input formats to the program. Even after publishing the code to the Github, it had been looked through multiple times, in order to find errors, typos and other kind of mistakes. At that stage, all necessary corrections have been made straight in Github.
And finally, deployment phase happened as we committed our software to Github.
Since we were creating a simple text program and it did not consider creating a proper user interface, or connection to a database, the only role for everyone of us was full stack developer with an addition of QA, since everyone did the testing as well.
Software development life cycle model of our project is Iterative Incremental model, because after the software itself was created, we tested it and analyzed the results, and did necessary additions, improvements, and corrections. That kind of cycle happened for a few times before the final version was published.  
For our final software product main environment is Visual Studio, or any other C# capable code interpreter. Besides that, the software is published in Github, and might be accessed as a web page via pc or mobile.
